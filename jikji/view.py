"""
	jikji/view
	---------------
	View, Page Class


	Jikji has a concept 'View', which is similar to 'Controller' on common backend framework
	One View has one 'URL rule', one 'View Function', and multiple 'Pages'.

	Usually, the controller has the role of taking the data from the model
	with the PARAMETERS in URL and returning the HTML with the View.

	In static web, PARAMETERS are provided in advance.
	There are many tuple set of parameters in ONE VIEW.

	Jikji calls the tuple 'Page'

	
	For example, 'Article View' has url rule '/posts/$1/$2'
	The sample PAGEs for 'Article View' will have the following.

	"/posts/dev/best-sublime-text-3-themes-of-2016"
	"/posts/dev/the-best-news-from-angulars-ng-conf"

	:author: Prev(prevdev@gmail.com)
"""

import inspect, os
from datetime import datetime
from . import utils


_processing_page_stack = []



def register_view(func=None, url_rule=None) :
	""" Register view to app
		Decorator function used in views/~.py
	"""
	from .app import Jikji
	app = Jikji.getinstance()


	if callable(func) :
		app.register_view(viewfunc=func)
		return func

	elif not func and url_rule :
		def decorator(func) :
			app.register_view(viewfunc=func, url_rule=url_rule)
			return func

		return decorator

	else :
		raise Exception('Error using view decorator')



def render_template(template_path, **context) :
	""" Render template and return result
	"""
	from .app import Jikji
	app = Jikji.getinstance()
	

	if os.path.splitext(template_path)[1] == '' :
		template_path += '.html'

	context['_page'] = {
 		'url': nowpage().geturl(),
 		'template': template_path,
 		'render_time': datetime.now(),
 		'params': nowpage().params,
	}

	tpl = app.jinja_env.get_template(template_path)
	return tpl.render( context )





def nowpage() :
	""" Get meta info of now-processing template
	"""
	global _processing_page_stack
	if len(_processing_page_stack) == 0:
		return None
	return _processing_page_stack[-1]



class View() :

	@staticmethod
	def parse_id(viewfunc, basepath) :
		""" Parse id from viewfunc and basepath
		"""

		# Get module of function
		module = inspect.getmodule(viewfunc)
		
		# Get relation path by module and basepath
		modulepath = os.path.relpath(module.__file__, basepath)
		rv = []
		for p in os.path.split(modulepath) :
			p2 = os.path.splitext(p)[0]
			if p2 :
				rv.append( p2 )

		rv.append(viewfunc.__name__)
		return '.'.join(rv)




	def __init__(self, id, viewfunc, url_rule=None, options=None) :
		""" View Constructor
		:param id: ID of view
		:param viewfunc: Function matched to view.
						  Page's content is generated by viewfunc call.
		:param url_rule: Rule of URL. One view has one URL RULE.
						 ex) /posts/$1/$2
						 	 /posts/{board_id}/{post_id}
						 Pages in views are classified by params in url rule
		:param options: Option param
		"""
		
		self.id = id
		self.viewfunc = viewfunc
		self.url_rule = url_rule
		self.options = options



class Page :
	def __init__(self, view, params) :
		""" Page Constructor
		:param view: Target View (if string, find view in app)
		:param params: Params of Page inserted in url rule
		"""
		from .app import Jikji
		app = Jikji.getinstance()

		if type(view) == str :
			view = app.getview(viewid=view)

		elif callable(view) :
			view = app.getview(viewfunc=view)

		self.view = view
		self.params = params


	def getcontent(self) :
		""" Get content of page
		"""
		global _processing_page_stack
		_processing_page_stack.append(self)

		if type(self.params) in (list, tuple) :
			# If 'params' is list or tuple, call with *args
			rv = self.view.viewfunc(*self.params)

		else :
			rv = self.view.viewfunc(self.params)

		_processing_page_stack.pop()
		return rv


	def geturl(self) :
		""" Get url of page by matching URL rule and params
		"""
		url = self.view.url_rule

		# Parse rule like "{var_name}" or "$n" from url and replace to param data
		url = utils.parse_varstr(url, self.params)
		return url



class PageGroup :

	def __init__(self, page=None, pages=None) :
		""" PageGroup Contructor
		:param page: if page, use single-instance page list
		:param pages: list of pages
		"""
		if page : 	self.pages = [page]
		else : 		self.pages = pages


	def getpages(self) :
		""" Get pages to be generated or listened
		"""
		return self.pages


	def get_representative_url(self) :
		""" Get representative url of PageGroup
			This url is used in distinguish PageGroups, and printed on generation
		"""
		return self.getpages()[0].geturl()



	def before_rendered(self) :
		""" Called before rendering start

		[!Notice] Rendering is executed in multi-process.
				  States in memory would not be preserved.
		"""
		pass


	def after_rendered(self, success_pages, errors, ignored_pages) :
		""" Called after rendering finished

		[!Notice] Rendering is executed in multi-process.
				  States in memory would not be preserved.
		"""
		pass


	def after_published(self, success_pages, errors, ignored_pages) :
		""" Called after published
		"""
		pass


